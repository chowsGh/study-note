## 存储结构与磁盘划分
### linux 系统中，目录、字符设备、块设备、套接字、打印机等都被抽象成了文件,这些文件都是从"/"(根目录)开始的。
- FHS 文件目录规范，是一个文件目录的规约

```
Linux系统中常见的目录名称以及相应内容

目录名称 	应放置文件的内容
/boot 	开机所需文件—内核、开机菜单以及所需配置文件等
/dev 	以文件形式存放任何设备与接口
/etc 	配置文件
/home 	用户主目录
/bin 	存放单用户模式下还可以操作的命令
/lib 	开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数
/sbin 	开机过程中需要的命令
/media 	用于挂载设备文件的目录
/opt 	放置第三方的软件
/root 	系统管理员的家目录
/srv 	一些网络服务的数据文件目录
/tmp 	任何人均可使用的“共享”临时目录
/proc 	虚拟文件系统，例如系统内核、进程、外部设备及网络状态等
/usr/local 	用户自行安装的软件
/usr/sbin 	Linux系统开机时不会使用到的软件/命令/脚本
/usr/share 	帮助与说明文件，也可放置共享文件
/var 	主要存放经常变化的文件，如日志
/lost+found 	当文件系统发生错误时，将一些丢失的文件片段存放在这里
```


### 文件系统与数据资料
- df 查看文件系统类型
    - df -T, type(类型) 表示文件系统的类型
- 部分文件系统类型
    - Ext3：是一款日志文件系统，能够在系统异常宕机时避免文件系统资料丢失，并能自动修复数据的不一致与错误。然而，当硬盘容量较大时，所需的修复时间也会很长，而且也不能百分之百地保证资料不会丢失。它会把整个磁盘的每个写入动作的细节都预先记录下来，以便在发生异常宕机后能回溯追踪到被中断的部分，然后尝试进行修复。
    - Ext4：Ext3的改进版本，作为RHEL 6系统中的默认文件管理系统，它支持的存储容量高达1EB（1EB=1,073,741,824GB），且能够有无限多的子目录。另外，Ext4文件系统能够批量分配block块，从而极大地提高了读写效率。
    - XFS：是一种高性能的日志文件系统，而且是RHEL 7中默认的文件管理系统，它的优势在发生意外宕机后尤其明显，即可以快速地恢复可能被破坏的文件，而且强大的日志功能只用花费极低的计算和存储性能。并且它最大可支持的存储容量为18EB，这几乎满足了所有需求。
    就像拿到了一张未裁切的完整纸张那样，我们首先要进行裁切以方便使用，然后在裁切后的纸张上画格以便能书写工整。在拿到了一块新的硬盘存储设备后，也需要先分区，然后再格式化文件系统，最后才能挂载并正常使用。硬盘的分区操作取决于您的需求和硬盘大小；您也可以选择不进行分区，但是必须对硬盘进行格式化处理。接下来刘遄老师再向大家简单地科普一下硬盘在格式化后发生的事情。再次强调，不用刻意去记住，只要能看懂就行了。

- 文件系统工作原理
    - 日常在硬盘需要保存的数据实在太多了，因此Linux系统中有一个名为**super block**的“硬盘地图”。Linux并不是把文件内容直接写入到这个“硬盘地图”里面，而是在里面记录着整个文件系统的信息。因为如果把所有的文件内容都写入到这里面，它的体积将变得非常大，而且文件内容的查询与写入速度也会变得很慢。Linux只是把每个文件的权限与属性记录在inode中，而且每个文件占用一个独立的inode表格，该表格的大小默认为128字节，里面记录着如下信息：
```
        该文件的访问权限（read、write、execute）；

        该文件的所有者与所属组（owner、group）；

        该文件的大小（size）；

        该文件的创建或内容修改时间（ctime）；

        该文件的最后一次访问时间（atime）；

        该文件的修改时间（mtime）；

        文件的特殊权限（SUID、SGID、SBIT）；

        该文件的真实数据地址（point）。
```
    而文件的实际内容则保存在block块中（大小可以是1KB、2KB或4KB），一个**inode**的默认大小仅为128B（Ext3），记录一个block则消耗4B。当文件的inode被写满后，Linux系统会自动分配出一个block块，专门用于像inode那样记录其他block块的信息，这样把各个block块的内容串到一起，就能够让用户读到完整的文件内容了。对于存储文件内容的block块，有下面两种常见情况（以4KB的block大小为例进行说明）。
```
        情况1：文件很小（1KB），但依然会占用一个block，因此会潜在地浪费3KB。

        情况2：文件很大（5KB），那么会占用两个block（5KB-4KB后剩下的1KB也要占用一个block）。
```
    - VFS（Virtual File System，虚拟文件系统）, Linux内核中的软件层为用户程序提供了一个VFS（Virtual File System，虚拟文件系统）接。这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。图6-5所示为VFS的架构示意图。从中可见，实际文件系统在VFS下隐藏了自己的特性和细节，这样用户在日常使用时会觉得“文件系统都是一样的”，也就可以随意使用各种命令在任何文件系统中进行各种操作了（比如使用cp命令来复制文件）。
### 挂载硬件设备
    - [虚拟机扩展磁盘](http://blog.csdn.net/chengyuqiang/article/details/59491942)
    - https://www.linuxprobe.com/chapter-06.html;
### fdisk 命令管理磁盘分区
- fdisk -l
- fdisk /dev/sda
### 磁盘容量配额
- Linux系统的设计初衷就是让许多人一起使用并执行各自的任务，从而成为多用户、多任务的操作系统。但是，硬件资源是固定且有限的，如果某些用户不断地在Linux系统上创建文件或者存放电影，硬盘空间总有一天会被占满。针对这种情况，root管理员就需要使用磁盘容量配额服务来限制某位用户或某个用户组针对特定文件夹可以使用的最大硬盘空间或最大文件个数，一旦达到这个最大值就不再允许继续使用。可以使用quota命令进行磁盘容量配额管理，从而限制用户的硬盘可用容量或所能创建的最大文件个数。quota命令还有软限制和硬限制的功能。
### 软硬方式链接
- 硬链接（hard link）：可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。**我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时****，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。
- 软链接（也称为符号链接[symbolic link]）：仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。
- ln命令, ln命令用于创建链接文件，格式为“ln [选项] 目标”，其可用的参数以及作用如表6-6所示。在使用ln命令时，是否添加-s参数，将创建出性质不同的两种“快捷方式”。因此如果没有扎实的理论知识和实践经验做铺垫，尽管能够成功完成实验，但永远不会明白为什么会成功。
```
表6-6                                             ln命令中可用的参数以及作用
参数 	作用
-s 	创建“符号链接”（如果不带-s参数，则默认创建硬链接）
-f 	强制创建文件或目录的链接
-i 	覆盖前先询问
-v 	显示创建链接的过程
```
为了更好地理解软链接、硬链接的不同性质，接下来创建一个类似于Windows系统中快捷方式的软链接。这样，当原始文件被删除后，就无法读取新建的链接文件了。
```
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > readme.txt
[root@linuxprobe ~]# ln -s readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt
-rw-r--r-- 1 root root 26 Jan 11 00:08 readme.txt
[root@linuxprobe ~]# rm -f readme.txt
[root@linuxprobe ~]# cat readit.txt
cat: readit.txt: No such file or directory
```
接下来针对一个原始文件创建一个硬链接，即相当于针对原始文件的硬盘存储位置创建了一个指针，这样一来，新创建的这个硬链接就不再依赖于原始文件的名称等信息，也不会因为原始文件的删除而导致无法读取。同时可以看到创建硬链接后，原始文件的硬盘链接数量增加到了2。
```
[root@linuxprobe ~]# echo "Welcome to linuxprobe.com" > readme.txt
[root@linuxprobe ~]# ln readme.txt readit.txt
[root@linuxprobe ~]# cat readme.txt
Welcome to linuxprobe.com
[root@linuxprobe ~]# cat readit.txt
Welcome to linuxprobe.com
[root@linuxprobe ~]# ls -l readme.txt
-rw-r--r-- 2 root root 26 Jan 11 00:13 readme.txt
[root@linuxprobe ~]# rm -f readme.txt
[root@linuxprobe ~]# cat readit.txt
Welcome to linuxprobe.com
```

## 使用RAID与LVM磁盘阵列技术。
- 常用RAID（Redundant Array of Independent Disks，独立冗余磁盘阵列）技术方案的特性，并通过实际部署RAID 10、RAID 5+备份盘等方案来更直观地查看RAID的强大效果，以便进一步满足生产环境对硬盘设备的IO读写速度和数据冗余备份机制的需求。同时，考虑到用户可能会动态调整存储资源，本章还将介绍LVM（Logical Volume Manager，逻辑卷管理器）的部署、扩容、缩小、快照以及卸载删除的相关知识。相信读者在学完本章内容后，便可以在企业级生产环境中灵活运用RAID和LVM来满足对存储资源的高级管理需求了。

### RAID磁盘冗余阵列
近年来， CPU的处理性能保持着高速增长，Intel公司在2017年最新发布的i9-7980XE处理器芯片更是达到了18核心36线程。但与此同时，硬盘设备的性能提升却不是很大，因此逐渐成为当代计算机整体性能的瓶颈。而且，由于硬盘设备需要进行持续、频繁、大量的IO操作，相较于其他设备，其损坏几率也大幅增加，导致重要数据丢失的几率也随之增加。
1988年，加利福尼亚大学伯克利分校首次提出并定义了RAID技术的概念。RAID技术通过把多个硬盘设备组合成一个容量更大、安全性更好的磁盘阵列，并把数据切割成多个区段后分别存放在各个不同的物理硬盘设备上，然后利用分散读写技术来提升磁盘阵列整体的性能，同时把多个重要数据的副本同步到不同的物理硬盘设备上，从而起到了非常好的数据冗余备份效果。
任何事物都有它的两面性。RAID技术确实具有非常好的数据冗余备份功能，但是它也相应地提高了成本支出。就像原本我们只有一个电话本，但是为了避免遗失，我们将联系人号码信息写成了两份，自然要为此多买一个电话本，这也就相应地提升了成本支出。RAID技术的设计初衷是减少因为采购硬盘设备带来的费用支出，但是与数据本身的价值相比较，现代企业更看重的则是RAID技术所具备的冗余备份机制以及带来的硬盘吞吐量的提升。也就是说，RAID不仅降低了硬盘设备损坏后丢失数据的几率，还提升了硬盘设备的读写速度，所以它在绝大多数运营商或大中型企业中得以广泛部署和应用。
出于成本和技术方面的考虑，需要针对不同的需求在数据可靠性及读写性能上作出权衡，制定出满足各自需求的不同方案。目前已有的RAID磁盘阵列的方案至少有十几种，而刘遄老师接下来会详细讲解RAID 0、RAID 1、RAID 5与RAID 10这4种最常见的方案。
- **RAID 0** 技术把多块物理硬盘设备（至少两块）通过硬件或软件的方式串联在一起，组成一个大的卷组，并将数据依次写入到各个物理硬盘中。这样一来，在最理想的状态下，硬盘设备的读写性能会提升数倍，但是若任意一块硬盘发生故障将导致整个系统的数据都受到破坏。通俗来说，RAID 0技术能够有效地提升硬盘数据的吞吐速度，但是不具备数据备份和错误修复能力。如图7-1所示，数据被分别写入到不同的硬盘设备中，即disk1和disk2硬盘设备会分别保存数据资料，最终实现提升读取、写入速度的效果。
- **RAID 1** 尽管RAID 0技术提升了硬盘设备的读写速度，但是它是将数据依次写入到各个物理硬盘中，也就是说，它的数据是分开存放的，其中任何一块硬盘发生故障都会损坏整个系统的数据。因此，如果生产环境对硬盘设备的读写速度没有要求，而是希望增加数据的安全性时，就需要用到RAID 1技术了。
。它是把两块以上的硬盘设备进行绑定，在写入数据时，是将数据同时写入到多块硬盘设备上（可以将其视为数据的镜像或备份）。当其中某一块硬盘发生故障后，一般会立即自动以热交换的方式来恢复数据的正常使用。
- **RAID 5** RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID 5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块硬盘设备中，而是存储到除自身以外的其他每一块硬盘设备上，这样的好处是其中任何一设备损坏后不至于出现致命缺陷；图7-3中parity部分存放的就是数据的奇偶校验信息，换句话说，就是RAID 5技术实际上没有备份硬盘中的真实数据信息，而是当硬盘设备出现问题后通过奇偶校验信息来尝试重建损坏的数据。RAID这样的技术特性“妥协”地兼顾了硬盘设备的读写速度、数据安全性与存储成本问题。
- **RAID 10** 鉴于RAID 5技术是因为硬盘设备的成本问题对读写速度和数据的安全性能而有了一定的妥协，但是大部分企业更在乎的是数据本身的价值而非硬盘价格，因此生产环境中主要使用RAID 10技术。
顾名思义，RAID 10技术是RAID 1+RAID 0技术的一个“组合体”。如图7-4所示，RAID 10技术需要至少4块硬盘来组建，其中先分别两两制作成RAID 1磁盘阵列，以保证数据的安全性；然后再对两个RAID 1磁盘阵列实施RAID 0技术，进一步提高硬盘设备的读写速度。这样从理论上来讲，只要坏的不是同一组中的所有硬盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于RAID 10技术继承了RAID 0的高读写速度和RAID 1的数据安全性，在不考虑成本的情况下RAID 10的性能都超过了RAID 5，因此当前成为广泛使用的一种存储技术。

## [iptables & firewalld](https://www.linuxprobe.com/chapter-08.html)

## 配置网卡
- nmtui
- nmcli connection show 查看网卡信息
## sshd 服务
- 配置文件/etc/ssh/sshd_config

## SElinux
- linux 由于原有的权限管理系统会导致一些安全问题，所以引入了强化版权限管理 security enhanced linux
- getenforce 查看当前SElinux 模式
  - enforcing：强制模式，代表 SELinux 运行中，且已经正确的开始限制 domain/type 了；
  - permissive：宽容模式：代表 SELinux 运行中，不过仅会有警告信息并不会实际限制 domain/type 的存取。这种模式可以运来作为 SELinux 的 debug 之用；
  - disabled：关闭，SELinux 并没有实际运行。
- /etc/selinux/config 中修改 模式SELINUX={{mode}}
- 使用chcon（change selinux context）
- 查看权限审计 前提是已经开启了auditd , /var/log/audit/audit.log
- 使用 audit2why < /var/log/audit/audit.log > 1.txt 查看分析后的原因
- 使用 audit2allow < /var/log/audit/audit.log > 1.txt 生成 策略
- http://cn.linux.vbird.org/linux_basic/0440processcontrol_5.php
- 在开发调试的系统里可以关闭selinux 来加快开发调试节奏
