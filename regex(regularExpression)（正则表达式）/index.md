## 概览
- 分组
	- ()
	- ```(?'group_name'exp)```
	- ```\k'word'```
	- ```(?<group_name>exp)```
	- ```\k<word>```
- 断言
	断言不占用匹配，'!'表示不匹配
	- ```(?<=exp)exp1```
	- ```(?<!exp)exp1```
	- ```exp1(?=exp)```
	- ```exp1(?!exp)```
- 元字符
```
代码	说明	
.	匹配除换行符以外的任意字符	
\w	匹配字母或数字或下划线或汉字	
\s	匹配任意的空白符	
\d	匹配数字 	
\b	匹配单词的开始或结束	
^	匹配字符串的开始	
$	匹配字符串的结束	
```
- 需要转义的字符：```* . ? + $ ^ [ ] ( ) { } | \```。需要前置```\```

## 入门
正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。
许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。
## 元字符
```
代码	说明
.	匹配除换行符以外的任意字符
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串的结束
```
## 字符转义
如果你想查找元字符本身的话，就需要**转义**字符 '\'

```
* . ? + $ ^ [ ] ( ) { } | \
比如你查找'.',或者'*',就出现了问题：你没办法指定它们，
因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\.
```
## 重复
接在元字符，字符，组的后面表示重复例如：
\w+ 多个字母数字汉字或下划线
```
代码/语法	说明
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次
```

## 字符类
方括号表示一个集合，匹配集合中的任何一个字符
例如：
``` regex
[abcd]+ 表示a,b,c,d任意一个字符出现1次就可匹配 
\(?0\d{2}[)\s-]?\d{8} 
```

## 分枝条件
用 | 表示 或 分支条件
短路效应，如果已经判断匹配则不会继续与后面的匹配，使用分枝条件时，要注意各个条件的顺序。
```
常见用法
(efg|abc){2} 表示"efg"和"abc"这两个字符串总共出现两次
0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。
注意顺序 例如12345-1234如果用这个\d{5}-\d{4}|\d{5}可以匹配全部，但是将这个表达式\d{5}|\d{5}-\d{4} 则会优先匹配12345后面的匹配失效。

```
## 分组
- **分组0**对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
- 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．

用**```()```**来表示分组。
我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。

```
(\d{1,3}\.){3}\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：
\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号
(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。

IP地址中每个数字都不能大于255. 经常有人问我, 
01.02.03.04 这样前面带有0的数字, 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes).
不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。
如果能使用算术比较的话，或许能简单地解决这个问题，
但是正则表达式中并不提供关于数学的任何功能，
所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：
((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。
理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。
```

## 反义
一些元字符将字符大写则表示取反例如：\\S	匹配任意不是空白符的字符
表3.常用的反义代码
```
代码/语法	说明
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符
```

## 后向引用
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。	
**后向引用**用于重复搜索前面某个分组匹配的文本。

- 形式一 
``` \{group_num}。``` **\1**代表分组1匹配的文本。难以理解？请看示例：	
\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。

- 形式二
**``` (?<{group_name}>{exp}) 或 (?'{group_name}'{exp}) ```**	
后面的引用是使用 **``` \k'{group_name}' 或 \k<{group_name}> ```**
你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：```(?<Word>\w+)```或者把尖括号换成'也行：```(?'Word'\w+)```,这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：```\b(?<Word>\w+)\b\s+\k<Word>\b```。
```
表4.常用分组语法
分类	代码/语法		说明
捕获	(exp)			匹配exp,并捕获文本到自动命名的组里
		(?<name>exp)	匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
		(?:exp)			匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言(?=exp)			匹配exp前面的位置
		(?<=exp)		匹配exp后面的位置
		(?!exp)			匹配后面跟的不是exp的位置
		(?<!exp)		匹配前面不是exp的位置
注释	(?#comment)		这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读
```		
(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号

## 断言 assert 
一个假设判断。		
编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。断言表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真。可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言，而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新起用断言。
## 零宽断言 | 负向零宽断言
- 零宽断言
	- (?=exp) 也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。	
	- (?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如**```(?<=\bre)\w+\b```**会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
- 负向零宽断言 | 与上类似将'='换成了'!'
	- (?!exp) 也叫零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
	- (?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。		
一个更复杂的例子：```(?<=<(\w+)>).*(?=<\/\1>)```匹配某个完整标签中的内容。例如：```<div><p>一段话</p></div>```将会匹配到```<p>一段话</p>```

## 贪婪与懒惰
在重复的表达式后面加上一个'?'则表示为懒惰模式。
匹配最少的重复。
```
表5.懒惰限定符
代码/语法			说明	
*?					重复任意次，但尽可能少重复	
+?					重复1次或更多次，但尽可能少重复	
??					重复0次或1次，但尽可能少重复	
{n,m}?				重复n到m次，但尽可能少重复	
{n,}?				重复n次以上，但尽可能少重复	
```
## 平衡组/递归匹配
这里需要用到以下的语法构造：

- **(?'group')** 把捕获的内容命名为group,并压入堆栈(Stack)
- **(?'-group')** 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- **(?(group)yes|no)** 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- **(?!)** 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

```
有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)
则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)
。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )
，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？
为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。
现在我们的问题变成了如何把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？

如果你不是一个程序员（或者你自称程序员但是不知道堆栈是什么东西），你就这样理解上面的三种语法吧：第一个就是在黑板上写一个"group"，第二个就是从黑板上擦掉一个"group"，第三个就是看黑板上写的还有没有"group"，如果有就继续匹配yes部分，否则就匹配no部分。
我们需要做的是每碰到了左括号，就在压入一个"Open",每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。
<                         #最外层的左括号
    [^<>]*                #最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)    #碰到了左括号，在黑板上写一个"Open"
            [^<>]*       #匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>)   #碰到了右括号，擦掉一个"Open"
            [^<>]*        #匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的"Open"；如果还有，则匹配失败

>                         #最外层的右括号
平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：
<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>.
```
## etc
```
表7.尚未详细讨论的语法
代码/语法	说明
\a	报警字符(打印它的效果是电脑嘀一声)
\b	通常是单词分界位置，但如果在字符类里使用代表退格
\t	制表符，Tab
\r	回车
\v	竖向制表符
\f	换页符
\n	换行符
\e	Escape
\0nn	ASCII代码中八进制代码为nn的字符
\xnn	ASCII代码中十六进制代码为nn的字符
\unnnn	Unicode代码中十六进制代码为nnnn的字符
\cN	ASCII控制字符。比如\cC代表Ctrl+C
\A	字符串开头(类似^，但不受处理多行选项的影响)
\Z	字符串结尾或行尾(不受处理多行选项的影响)
\z	字符串结尾(类似$，但不受处理多行选项的影响)
\G	当前搜索的开头
\p{name}	Unicode中命名为name的字符类，例如\p{IsGreek}
(?>exp)	贪婪子表达式
(?<x>-<y>exp)	平衡组
(?im-nsx:exp)	在子表达式exp中改变处理选项
(?im-nsx)	为表达式后面的部分改变处理选项
(?(exp)yes|no)	把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no
(?(exp)yes)	同上，只是使用空表达式作为no
(?(name)yes|no)	如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no
(?(name)yes)	同上，只是使用空表达式作为no
```

## 参考
- [【正则表达式30分钟入门教程】](http://deerchao.net/tutorials/regex/regex.htm)
- [ .NET Framework 正则表达式语言 - 快速参考](https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx)
- [Java 正则表达式](http://www.runoob.com/java/java-regular-expressions.html)
- [js正则表达式](http://www.w3school.com.cn/js/js_obj_regexp.asp)
- [js正则表达式](http://www.runoob.com/js/js-obj-regexp.html)
- [正则表达式之分组捕获、条件表达式、平衡组](http://blog.csdn.net/wanglei19880622/article/details/7204492)